### 递归
递归中存在的问题： 
- 堆栈溢出
- 重复计算  
递归中存在重复计算的问题 
为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。  
- 在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销

### 排序
- 原地排序(Sorted in place)  
  原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。冒泡、插入、选择都是原地排序算法  
  归并排序不是原地排序，这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。而不是O(nlogn)  
  快速排序的分区点操作是数据交换空间复杂度是O(1),所以快速排序是原地排序
- 稳定的排序算法  
  A与B相等，A在B前，如果排完序后A仍在B前(前后位置未发生变化)，则认为是稳定的排序算法，如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。  
  冒泡排序 插入排序 是稳定的排序算法。  
  选择排序不是稳定的排序算法：选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。  
  举个例子，比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。  
  归并排序稳不稳定关键要看 merge() 函数，也就是两个有序子数组合并成一个有序数组的那部分代码。在合并的过程中，如果 A[p...q]和 A[q+1...r]之间有值相同的元素，那我们可以像伪代码中那样，先把 A[p...q]中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。  
  快速排序是不稳定的排序，距离[1,6,2,8,3,1,8,5] pivot选择5，单边扫描切分后[1,2,3,1,5,8,8,6]两个8的先后顺序变化了，所以快速排序不是稳定排序。
- 冒泡排序时间复杂度  
  最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n<sup>2</sup>)。  
  ```
  最好情况: 1,2,3,4,5,6 一次冒泡 时间复杂度O(n)  
  最坏情况：6,5,4,3,2,1 6次冒泡  时间复杂度O(n2)
  ```
- 插入排序时间复杂度  
  如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是**从尾到头遍历已经有序的数据**。  
  如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n<sup>2</sup>)。  
  还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n<sup>2</sup>)。
- 选择排序时间复杂度  
  选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。
- 插入排序和冒泡排序的时间复杂度相同，都是 O(n<sup>2</sup>)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？  
  从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：  
  ````java
    冒泡排序中数据的交换操作：
    if (a[j] > a[j+1]) { // 交换
      int tmp = a[j];
      a[j] = a[j+1];
      a[j+1] = tmp;
      flag = true;
    }
    
    插入排序中数据的移动操作：
    if (a[j] > value) {
      a[j+1] = a[j];  // 数据移动
    } else {
      break;
    }
  ````
  我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。  
  这个只是我们非常理论的分析，为了实验，针对上面的冒泡排序和插入排序的 Java 代码，我写了一个性能对比测试程序，随机生成 10000 个数组，每个数组中包含 200 个数据，然后在我的机器上分别用冒泡和插入排序算法来排序，冒泡排序算法大约 700ms 才能执行完成，而插入排序只需要 100ms 左右就能搞定！  
  所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n<sup>2</sup>)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，我们只是讲了最基础的一种。如果你对插入排序的优化感兴趣，可以自行学习一下 **希尔排序**。  
- 归并排序的时间复杂度
  ```java
  T(n) = 2*T(n/2) + n //参考递推公式，2部分加起来 让后加上merger的复杂度
    = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
    = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
    = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
    ......
    = 2^k * T(n/2^k) + k * n
    ......
  ```  
  通过这样一步一步分解推导，我们可以得到 T(n) = 2<sup>k</sup> T(n/(2^k))+kn。当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以归并排序的时间复杂度是 O(nlogn)。
- 快速排序的时间复杂度，同意采用递归方式求解得到O(nlogn)  
  极端的例子。如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。  
  
  | |是原地排序？|是否稳定？|最好|最坏|平均|
  |---|---|---|---|---|---|
  |冒泡排序|是|是|O(n)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|
  |插入排序|是|是|O(n)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|
  |选择排序|是|否|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|
  |归并排序|否 每轮O(n)|是|O(nlogn)|O(nlogn)|O(nlongn)|
  |快速排序|是|否|O(nlogn)|O(n<sup>2</sup>）|O(nlogn)|
  |计数排序|否|是| | |O(n+k)k是数据范围 |
  |桶排序|否|是| | |O(n)|
  |基数排序|否|是| | |O(dn)d是维度|  
- 如何优化快速排序  
  如果很粗暴地直接选择第一个或者最后一个数据作为分区点，不考虑数据的特点，肯定会出现之前讲的那样，在某些情况下，排序的最坏情况时间复杂度是 O(n2)。为了提高排序算法的性能，我们也要尽可能地让每次分区都比较平均。我这里介绍两个比较常用、比较简单的分区算法，你可以直观地感受一下。  
  - 三数取中法  
    我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。  
  - 随机法  
    随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。  
    
